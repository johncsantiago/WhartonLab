---
title: "Lean Top PC1 Function Figures"
author: "John Santiago"
date: "11/28/2020"
output: html_document
---

```{r setup, include=FALSE}
library(rgl)
knitr::opts_chunk$set(echo = FALSE, fig.align="center")
knitr::knit_hooks$set(webgl = hook_webgl)
```

```{r include=F}
##Load Libraries
library(tidyverse)
library(edgeR)
library(pca3d) # Requires XQuartz on macOS X
library(ggfortify)
library(directlabels)
library(plot3D)
library(rgl)
library(plot3Drgl)
library(heatmaply)
library(gplots)
library(biomaRt)
library(scatterplot3d)
library(org.Hs.eg.db)
library(goseq)
library(reshape2)
library(GO.db)
library(igraph)
library(clusterProfiler)
library(visNetwork)
library(circlize)
```

```{r}
x1=as.list(org.Hs.egENSEMBL2EG)
x2=as.list(org.Hs.egSYMBOL)
x3=as.list(org.Hs.egSYMBOL2EG)
x4=as.list(org.Hs.egENSEMBL)



ccpar=as.list(GOCCPARENTS)
ccchild=as.list(GOCCCHILDREN)

bppar=as.list(GOBPPARENTS)
bpchild=as.list(GOBPCHILDREN)

mfpar=as.list(GOMFPARENTS)
mfchild=as.list(GOMFCHILDREN)

term=as.list(GOTERM)

genesingo=as.list(org.Hs.egGO2ALLEGS)

##bm = useMart("ensembl")
##bm = useDataset("hsapiens_gene_ensembl", mart=bm)
##EG2GO = getBM(mart=bm, attributes=c('ensembl_gene_id','go_id'))

##geneID2GO = by(EG2GO$go_id,
                ##EG2GO$ensembl_gene_id,
                ##function(x) as.character(x))

##GO2geneID = by(EG2GO$ensembl_gene_id,
                ##EG2GO$go_id,
                ##function(x) as.character(x))

##save(geneID2GO, file="/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/geneID2GO.RData")
##save(GO2geneID, file="/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/GO2geneID.RData")
##save(GO2geneID, file="/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/GO2geneID.RData")
load("/Users/johncsantiago/Google Drive/My Drive/Sanders Lab Files/All Code/geneID2GO.RData")
load("/Users/johncsantiago/Google Drive/My Drive/Sanders Lab Files/All Code/GO2geneID.RData")





GOnetwork=function(ont,parent,child,GOlist,goi){
##generates a vector of all genes in the GOlist with associated GOterms as names
  GOterms=GOlist$category[GOlist$ontology==ont&GOlist$adjp<.5]
  allgogenes=unlist(GO2geneID[GOterms])
  gogenes=intersect(allgogenes,goi)
  edge.data=c(allgogenes[allgogenes==gogenes[1]])
  i=2
  while(i<=length(gogenes)){
    edge.data=c(edge.data,allgogenes[allgogenes==gogenes[i]])
    i=i+1
  }
  names(edge.data)=substring(names(edge.data),1,10)

##generates a table with all parent terms for each significant GO term
  temp=GOlist$category[GOlist$adjp<.05&GOlist$ontology==ont]
  temp2=parent[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp4
  temp7[,2]=temp6
  temp7[,3]=temp5
  colnames(temp7)=c("parent","relationship","child")
  edges=temp7


##generates a table with all child terms for each significant GO term
  temp=GOlist$category[GOlist$adjp<.05&GOlist$ontology==ont]
  temp2=child[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp5
  temp7[,2]=temp6
  temp7[,3]=temp4
  colnames(temp7)=c("parent","relationship","child")

edges=rbind(edges,temp7)

gooiedges=unique(edges[,c(1,3)])
colnames(gooiedges)=c("from","to")
gooiedges=na.omit(gooiedges)

i=1
while(i<=nrow(gooiedges)){
  if(length(GOlist$term[GOlist$category==gooiedges[i,1]])>0){
    gooiedges[i,1]=GOlist$term[GOlist$category==gooiedges[i,1]]
  }else{
      gooiedges[i,1]=Term(term[[as.character(gooiedges[i,1])]])
  }
  
  if(length(GOlist$term[GOlist$category==gooiedges[i,2]])>0){
    gooiedges[i,2]=GOlist$term[GOlist$category==gooiedges[i,2]]
  }else{
    gooiedges[i,2]=Term(term[[as.character(gooiedges[i,2])]])
  }
  i=i+1
}


nodeid=unique(c(gooiedges[,1],gooiedges[,2]))

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    gooiedges[,1],
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

  if(length(intersect(
    intersect( setdiff(gooiedges[,1],gooiedges[,2]),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  i=i+1
}

notsigs=nodeid[nodegroups=="not sig."]
nodeid=nodeid[nodegroups!="not sig."]
nodegroups=nodegroups[nodegroups!="not sig."]

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }  
  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

    if(length(intersect(
    intersect( setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont][1:5]))>0){
    nodegroups[i]="Top 5 Sig. Enriched"
  }
  i=i+1
}

nodesize=c(rep(.1,length(nodeid)))
i=1
while(i<=length(nodeid)){
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodesize[i]=GOlist[GOlist$term==nodeid[i],4]
  }
  i=i+1
}


nodes=data.frame(id=nodeid,group=nodegroups,value=nodesize)
visedges=as.data.frame(gooiedges)
colnames(visedges)=c("from","to")
visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "Parent Term", shape = "square", color = list(background = "yellow", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Top 5 Sig. Enriched", shape = "dot", color = list(background = "red", border="firebrick", groupname="white"),physics=T,font=list(color="black"))%>%
  visGroups(groupname = "Not sig. Parent Term", shape = "square", color = list(background = "grey", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "yellow", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)
}



childGOnetwork=function(ont,parent,child,GOlist,goi){
##generates a vector of all genes in the GOlist with associated GOterms as names
  GOterms=GOlist$category[GOlist$ontology==ont&GOlist$adjp<.5]
  allgogenes=unlist(GO2geneID[GOterms])
  gogenes=intersect(allgogenes,goi)
  edge.data=c(allgogenes[allgogenes==gogenes[1]])
  i=2
  while(i<=length(gogenes)){
    edge.data=c(edge.data,allgogenes[allgogenes==gogenes[i]])
    i=i+1
  }
  names(edge.data)=substring(names(edge.data),1,10)

##generates a table with all child terms for each significant GO term
  temp=GOlist$category[GOlist$adjp<.05&GOlist$ontology==ont]
  temp2=child[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp5
  temp7[,2]=temp6
  temp7[,3]=temp4
  colnames(temp7)=c("parent","relationship","child")

edges=temp7

gooiedges=unique(edges[,c(1,3)])
colnames(gooiedges)=c("from","to")
gooiedges=na.omit(gooiedges)

i=1
while(i<=nrow(gooiedges)){
  if(length(GOlist$term[GOlist$category==gooiedges[i,1]])>0){
    gooiedges[i,1]=GOlist$term[GOlist$category==gooiedges[i,1]]
  }else{
      gooiedges[i,1]=Term(term[[as.character(gooiedges[i,1])]])
  }
  
  if(length(GOlist$term[GOlist$category==gooiedges[i,2]])>0){
    gooiedges[i,2]=GOlist$term[GOlist$category==gooiedges[i,2]]
  }else{
    gooiedges[i,2]=Term(term[[as.character(gooiedges[i,2])]])
  }
  i=i+1
}



nodeid=unique(c(gooiedges[,1],gooiedges[,2]))

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    gooiedges[,1],
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

  if(length(intersect(
    intersect( setdiff(gooiedges[,1],gooiedges[,2]),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  i=i+1
}

notsigs=nodeid[nodegroups=="not sig."]
nodeid=nodeid[nodegroups!="not sig."]
nodegroups=nodegroups[nodegroups!="not sig."]

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }  
  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

    if(length(intersect(
    intersect( setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  

  i=i+1
}

nodesize=c(rep(.1,length(nodeid)))
i=1
while(i<=length(nodeid)){
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodesize[i]=GOlist[GOlist$term==nodeid[i],4]
  }
  i=i+1
}


nodes=data.frame(id=nodeid,group=nodegroups,value=nodesize)
visedges=as.data.frame(gooiedges)
colnames(visedges)=c("from","to")
visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "Parent Term", shape = "square", color = list(background = "yellow", border="black", groupname="white"),physics=F,font=list(color="black"))%>%

  visGroups(groupname = "Not sig. Parent Term", shape = "square", color = list(background = "grey", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "yellow", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)
}

```


```{r include =F}
countdata=read.csv("/Users/johncsantiago/Documents/GitHub/SandersLab/MGH_2020/RNA-Seq Data Files/mgh_raw_countdata.csv",row.names=1)
groups=read.csv("/Users/johncsantiago/Documents/GitHub/SandersLab/MGH_2020/RNA-Seq Data Files/mgh_metadata.csv",row.names=1)


LiverMetrics = read.csv("https://raw.githubusercontent.com/johncsantiago/Lactate-Correlation-Manuscript/master/Data/AllLiverTraitData.csv", row.names=1)
LiverMetrics=LiverMetrics[-na.action(na.omit(LiverMetrics$RNAseq.ID)),]
LiverMetrics = LiverMetrics[-na.action(na.omit(LiverMetrics$Function)),]
countdata = countdata[,LiverMetrics$RNAseq.ID]
groups=groups[LiverMetrics$RNAseq.ID,]


##EdgeR comparisons
countdata=countdata[,row.names(groups)]
##countdata=countdata[,groups$fat=="F"]
##groups=groups[groups$fat=="F",]
countdata=countdata[,row.names(groups)]
x <- countdata
group <- factor(groups$Group)
y <- DGEList(counts=x,group=group)
keep <- filterByExpr(y)
y <- y[keep,,keep.lib.sizes=FALSE] 
z <- calcNormFactors(y, method = "TMM") 
cpmdata=cpm(z)

##updated edger analysis pipeline
design<-model.matrix(~LiverMetrics$alactate)
colnames(design)[2] <- "Lactate"

design<-model.matrix(~0 + LiverMetrics$Function)
colnames(design) <- c('AF', 'IF', 'LF')

##z = estimateGLMCommonDisp(z,design, verbose=T)
##z = estimateGLMTrendedDisp(z,design)
##z = estimateGLMTagwiseDisp(z,design)
z = estimateDisp(z, design)
fit <- glmQLFit(z, design)


compare = makeContrasts(Lactate, levels=design)
lrt = glmQLFTest(fit,contrast=as.vector(compare))

##lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
AFLF=G_X_E$table
sigsAFLF=AFLF[AFLF$FDR<.05,]
plot(data[colnames(cpm.0H),'LacTime3H'], cpm.0H[row.names(sigsAFLF)[1],])


design<-model.matrix(~0+groups$Group)
colnames(design) <- levels(group)
z = estimateGLMCommonDisp(z,design, verbose=T)
z = estimateGLMTrendedDisp(z,design)
z = estimateGLMTagwiseDisp(z,design)
fit <- glmFit(z, design)

##comparisons
##3 hour NV vs 0 hour NV
compare = makeContrasts((LN2-LN1), levels=design)
lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
LN2=G_X_E$table

##6 hour NV vs 0 hour NV
compare = makeContrasts((LN3-LN1), levels=design)
lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
LN3=G_X_E$table

##3 hour V vs 0 hour V
compare = makeContrasts((LV2-LV1), levels=design)
lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
LV2=G_X_E$table

##6 hour V vs 0 hour V
compare = makeContrasts((LV3-LV1), levels=design)
lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
LV3=G_X_E$table

##0 hour V vs 0 hour NV
compare = makeContrasts((LV1-LN1), levels=design)
lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
L1=G_X_E$table

##3 hour V vs 3 hour NV
compare = makeContrasts((LV2-LN2), levels=design)
lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
L2=G_X_E$table

##6 hour V vs 6 hour NV
compare = makeContrasts((LV3-LN3), levels=design)
lrt <- glmLRT(fit,contrast=as.vector(compare))		
G_X_E<-topTags(lrt,adjust.method="BH",n = nrow(z$counts), sort.by="PValue")
L3=G_X_E$table

sLV2=LV2[LV2$FDR<.05,]
sLV3=LV3[LV3$FDR<.05,]
sLN2=LN2[LN2$FDR<.05,]
sLN3=LN3[LN3$FDR<.05,]
sL1=L1[L1$FDR<.05,]
sL2=L2[L2$FDR<.05,]
sL3=L3[L3$FDR<.05,]

cpmmean=cpmdata[,18:35]
colnames(cpmmean)[1:6]=c("LV 0H","LV 3H","LV 6H","LN 0H","LN 3H","LN 6H")
cpmmean[,1]=(cpmmean[,1]+cpmmean[,2]+cpmmean[,3])/3
cpmmean[,2]=(cpmmean[,4]+cpmmean[,5]+cpmmean[,6])/3
cpmmean[,3]=(cpmmean[,7]+cpmmean[,8]+cpmmean[,9])/3
cpmmean[,4]=(cpmmean[,10]+cpmmean[,11]+cpmmean[,12])/3
cpmmean[,5]=(cpmmean[,13]+cpmmean[,14]+cpmmean[,15])/3
cpmmean[,6]=(cpmmean[,16]+cpmmean[,17]+cpmmean[,18])/3
cpmmean=cpmmean[,1:6]



scalecpm=t(apply(cpmdata[,18:35], MARGIN = 1, FUN = scale ))
colnames(scalecpm)=colnames(cpmdata)[18:35]
scalemeancpm=t(apply(cpmmean, MARGIN = 1, FUN = scale ))
colnames(scalemeancpm)=c("LV 0H","LV 3H","LV 6H","LN 0H","LN 3H","LN 6H")

pca <- prcomp(t(cpmdata[,18:35]), scale.=TRUE) 
gr <- factor(row.names(groups))
contribution=pca$rotation

##Because the sum of the squares of all loadings for an individual principal component must sum to one, we can calculate what the loadings would be if all variables contributed equally to that principal component.

##Any variable that has a larger loading than this value (positive or negative) contributes more than one variable’s worth of information and would be regarded as an important contributor to that principal component.
equalloading.cutoff=sqrt(1/nrow(contribution))


PC1contribute=contribution[,1]
PC1contribute=PC1contribute[order(PC1contribute,decreasing=T)]

PC2contribute=contribution[,2]
PC2contribute=PC2contribute[order(PC2contribute,decreasing=T)]

PC3contribute=contribution[,3]
PC3contribute=PC3contribute[order(PC3contribute,decreasing=T)]

```

```{r , fig.align="center"}

xcoords=pca$x[,1]
ycoords=pca$x[,3]


eigs <- pca$sdev^2
ve=(eigs / sum(eigs))*100
ve=signif(ve,3)

pcacolors=c("darkgreen","red4")
text2D(x=xcoords,y=ycoords,labels = c(rep("",18)), 
       col=c(pcacolors[c(rep(1,9),rep(2,9))]),
       xlab=paste("PC1 (",ve[1],"%)",sep=""),ylab=paste("PC3 (",ve[3],"%)",sep=""),xlim=c(-150,150),ylim=c(-75,100))

lines2D(x=xcoords[c(1,4,7)],y=ycoords[c(1,4,7)],col=pcacolors[1],add=T,lty=1)
lines2D(x=xcoords[c(2,5,8)],y=ycoords[c(2,5,8)],col=pcacolors[1],add=T,lty=2)
lines2D(x=xcoords[c(3,6,9)],y=ycoords[c(3,6,9)],col=pcacolors[1],add=T,lty=3)
lines2D(x=xcoords[c(10,13,16)],y=ycoords[c(10,13,16)],col=pcacolors[2],add=T,lty=1)
lines2D(x=xcoords[c(11,14,17)],y=ycoords[c(11,14,17)],col=pcacolors[2],add=T,lty=2)
lines2D(x=xcoords[c(12,15,18)],y=ycoords[c(12,15,18)],col=pcacolors[2],add=T,lty=3)

points2D(x=xcoords[1:3],y=ycoords[1:3],type="p",colkey=F,col="darkgreen",add=T,pch=21,bg="green",cex=2)
points2D(x=xcoords[4:6],y=ycoords[4:6],type="p",colkey=F,col="darkgreen",add=T,pch=24,bg="green",cex=2)
points2D(x=xcoords[7:9],y=ycoords[7:9],type="p",colkey=F,col="darkgreen",add=T,pch=22,bg="green",cex=2)

points2D(x=xcoords[10:12],y=ycoords[10:12],type="p",colkey=F,col="red4",add=T,pch=21,bg="red",cex=2)
points2D(x=xcoords[13:15],y=ycoords[13:15],type="p",colkey=F,col="red4",add=T,pch=24,bg="red",cex=2)
points2D(x=xcoords[16:18],y=ycoords[16:18],type="p",colkey=F,col="red4",add=T,pch=22,bg="red",cex=2)

abline(h=0,lty=2)
abline(v=0,lty=2)

legend("topleft", legend=c("Lean Viable","Lean Non-Viable"),col=c("green3","red"),lty=1,bty="n",lwd=2)
```

```{r include=F}

PCcontribute=PC1contribute
loading=(PCcontribute)
eigs <- pca$sdev^2
ve=(eigs / sum(eigs))*100
percent.variation=signif(ve,4)

##The column sum of squares of the loadings (pca$rotation) are the variances of PCs.
percents=(PCcontribute*PCcontribute)
percents=percents[order(percents,decreasing=T)]
loading=loading[names(percents)]
percent2=percents
temppercent=0
i=1
while(i<=length(percents)){
  percents[i]=percents[i]+temppercent
  temppercent=percents[i]
  i=i+1
}

percents=percents[loading[names(percents)]>0]
hmd=names(percents)[percents<=.1]
toppc1=hmd
hmd=cpmdata[(hmd),18:35]

hmcolors=colorpanel(100,"royalblue4","white","firebrick4")
```

```{r include=F}
sigs=row.names(hmd)
bg=cpmdata[,1:2]
bg[,1]=0
bg[sigs,1]=1
genes=bg[,1]
names(genes)=row.names(bg)
table(genes)
pwf=nullp(genes,"hg19","ensGene")
head(pwf)

  GO.wall=goseq(pwf,"hg19","ensGene")
  GO.wall$adjp=p.adjust(GO.wall$over_represented_pvalue,method="BH")
  GO.wall$adjp=p.adjust(GO.wall$over_represented_pvalue,method="BH")

PC1GO=GO.wall

id2name=PC1GO$term
names(id2name)=PC1GO$category

name2id=PC1GO$category
names(name2id)=PC1GO$term

getGeneLists <- function(pwf, goterms, genome, ids){
  gene2cat <- getgo(rownames(pwf), genome, ids)
  cat2gene <- split(rep(names(gene2cat), sapply(gene2cat, length)),
                    unlist(gene2cat, use.names = FALSE))
  out <- list()
  for(term in goterms){
    tmp <- pwf[cat2gene[[term]],]
    tmp <- rownames(tmp[tmp$DEgenes > 0, ])
    out[[term]] <- tmp
  }
  out
}
PC1gtg <- getGeneLists(pwf, GO.wall$category, "hg19", "ensGene")
PC1hasgo=intersect(sigs,unlist(PC1gtg))
PC1nogo=setdiff(sigs,unlist(PC1gtg))
```

```{r fig.width=8,fig.height=8, fig.align="center"}
heatmaply(hmd[c(PC1hasgo,PC1nogo),],scale="row",trace="none",Colv = F,Rowv=F,cexRow = .1,main="Top 10% PC1 Contribution",col=hmcolors, dendrogram = "none",row_side_colors = c(rep("In Sig. GO",length(PC1hasgo)),rep("No Sig. GO",length(PC1nogo))),row_side_palette = c("In Sig. GO"="gold","No Sig. GO"="forestgreen"))
```

```{r fig.width=8,fig.height=8, fig.align="center"}
hmd.mean=hmd[,1:6]
colnames(hmd.mean)=c("LV 0H","LV 3H","LV 6H","LN 0H","LN 3H","LN 6H")
hmd.mean[,1]=(hmd[,1]+hmd[,2]+hmd[,3])/3
hmd.mean[,2]=(hmd[,4]+hmd[,5]+hmd[,6])/3
hmd.mean[,3]=(hmd[,7]+hmd[,8]+hmd[,9])/3
hmd.mean[,4]=(hmd[,10]+hmd[,11]+hmd[,12])/3
hmd.mean[,5]=(hmd[,13]+hmd[,14]+hmd[,15])/3
hmd.mean[,6]=(hmd[,16]+hmd[,17]+hmd[,18])/3



heatmaply(hmd.mean,scale="row",trace="none",Colv = F,cexRow = .1,main="Top 10% PC1 Contribution",col=hmcolors, dendrogram = "none",row_side_colors = c(rep("In Sig. GO",length(PC1hasgo)),rep("No Sig. GO",length(PC1nogo))),row_side_palette = c("In Sig. GO"="gold","No Sig. GO"="forestgreen"))
```

PC1 CC
Super general: nucleus, cytosol, protein containing complex, intracellular
```{r}
##"CC" "MF" "BP"
ont="CC"
##ccpar mfpar bppar
parent=ccpar
##ccchild mfchild bpchild
child=ccchild
##a GOseq output table
GOlist=PC1GO
goi=toppc1


##GOnetwork(ont,parent,child,GOlist,goi)
  
```

PC1 BP
ribosomal biogenesis, , regulation of translation, transcription, DNA-templated, Gene expression, RNA processing
PC1BPgroup 1: protein and rna export to and from the nucleus
                protein localization to nucleus/chromosome (transcription regulation)
                RNA transport to/from nucleus
PC1BPgroup 2: gene expression
                regulation of RNA splicing
                translation
                transcription, DNA templated
```{r}
##"CC" "MF" "BP"
ont="BP"
##ccpar mfpar bppar
parent=bppar
##ccchild mfchild bpchild
child=bpchild
##a GOseq output table
GOlist=PC1GO
goi=toppc1


##generates a vector of all genes in the GOlist with associated GOterms as names
  GOterms=GOlist$category[GOlist$ontology==ont&GOlist$adjp<.5]
  allgogenes=unlist(GO2geneID[GOterms])
  gogenes=intersect(allgogenes,goi)
  edge.data=c(allgogenes[allgogenes==gogenes[1]])
  i=2
  while(i<=length(gogenes)){
    edge.data=c(edge.data,allgogenes[allgogenes==gogenes[i]])
    i=i+1
  }
  names(edge.data)=substring(names(edge.data),1,10)

##generates a table with all parent terms for each significant GO term
  temp=GOlist$category[GOlist$adjp<.05&GOlist$ontology==ont]
  temp2=parent[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp4
  temp7[,2]=temp6
  temp7[,3]=temp5
  colnames(temp7)=c("parent","relationship","child")
  edges=temp7


##generates a table with all child terms for each significant GO term
  temp=GOlist$category[GOlist$adjp<.05&GOlist$ontology==ont]
  temp2=child[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp5
  temp7[,2]=temp6
  temp7[,3]=temp4
  colnames(temp7)=c("parent","relationship","child")

edges=rbind(edges,temp7)

gooiedges=unique(edges[,c(1,3)])
colnames(gooiedges)=c("from","to")
gooiedges=na.omit(gooiedges)

i=1
while(i<=nrow(gooiedges)){
  if(length(GOlist$term[GOlist$category==gooiedges[i,1]])>0){
    gooiedges[i,1]=GOlist$term[GOlist$category==gooiedges[i,1]]
  }else{
      gooiedges[i,1]=Term(term[[as.character(gooiedges[i,1])]])
  }
  
  if(length(GOlist$term[GOlist$category==gooiedges[i,2]])>0){
    gooiedges[i,2]=GOlist$term[GOlist$category==gooiedges[i,2]]
  }else{
    gooiedges[i,2]=Term(term[[as.character(gooiedges[i,2])]])
  }
  i=i+1
}


nodeid=unique(c(gooiedges[,1],gooiedges[,2]))

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    gooiedges[,1],
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

  if(length(intersect(
    intersect( setdiff(gooiedges[,1],gooiedges[,2]),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  i=i+1
}

notsigs=nodeid[nodegroups=="not sig."]
nodeid=nodeid[nodegroups!="not sig."]
nodegroups=nodegroups[nodegroups!="not sig."]

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }  
  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

    if(length(intersect(
    intersect( setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont][1:5]))>0){
    nodegroups[i]="Top 5 Sig. Enriched"
  }
  i=i+1
}

nodesize=c(rep(.1,length(nodeid)))
i=1
while(i<=length(nodeid)){
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodesize[i]=GOlist[GOlist$term==nodeid[i],4]
  }
  i=i+1
}


nodes=data.frame(id=nodeid,group=nodegroups,value=nodesize)
visedges=as.data.frame(gooiedges)
colnames(visedges)=c("from","to")
visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "Parent Term", shape = "square", color = list(background = "yellow", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Top 5 Sig. Enriched", shape = "dot", color = list(background = "red", border="firebrick", groupname="white"),physics=T,font=list(color="black"))%>%
  visGroups(groupname = "Not sig. Parent Term", shape = "square", color = list(background = "grey", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "yellow", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)

##GOnetwork(ont,parent,child,GOlist,goi)
  
PC1nodeid=nodeid
PC1groups=nodegroups
PC1size=nodesize
PC1edges=gooiedges


```


transport
  establishment of localization
    establishment of RNA localization
    establishment of 

```{r}

##"CC" "MF" "BP"
ont="BP"
##ccpar mfpar bppar
parent=bppar
##ccchild mfchild bpchild
child=bpchild
##a GOseq output table
tPC1=PC1GO
row.names(tPC1)=PC1GO$term
allsiggo=PC1GO$category[PC1GO$adjp<.05]
GOlist=tPC1["establishment of localization","category"]
goi=toppc1

##generates a table with all child terms for each significant GO term
  temp=tPC1["establishment of localization","category"]
  temp2=child[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp5
  temp7[,2]=temp6
  temp7[,3]=temp4
  colnames(temp7)=c("parent","relationship","child")
  allchildren=temp7
  tested=unique(allchildren[,1])
  while(length(setdiff(unique(allchildren[,3]),tested))>0){
    temp=setdiff(unique(allchildren[,3]),tested)[1]
    temp2=child[temp]
    temp3=unlist(temp2)
    temp4=as.vector(temp3)
    temp5=as.vector(substring(names(temp3),1,10))
    temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
    temp7=matrix(0,nrow=length(temp3),ncol=3)
    temp7[,1]=temp5
    temp7[,2]=temp6
    temp7[,3]=temp4
    colnames(temp7)=c("parent","relationship","child")
    tested=unique(c(tested,temp))
    allchildren=rbind(allchildren,temp7)
    temp=c(rep(0,nrow(allchildren)))
    i=1
    while(i<=length(temp)){
      temp[i]=length(intersect(allchildren[i,],allsiggo))
      i=i+1
    }
    allchildren=allchildren[temp>0,]
  
  }

  temp=c(rep(0,nrow(allchildren)))
  i=1
while(i<=length(temp)){
  temp[i]=length(intersect(allchildren[,3],allsiggo))
  i=i+1
}

allchildren=allchildren[temp>0,]


    
edges=allchildren

gooiedges=unique(edges[,c(1,3)])
colnames(gooiedges)=c("from","to")
gooiedges=na.omit(gooiedges)

GOlist=PC1GO
i=1
while(i<=nrow(gooiedges)){
  if(length(GOlist$term[GOlist$category==gooiedges[i,1]])>0){
    gooiedges[i,1]=GOlist$term[GOlist$category==gooiedges[i,1]]
  }else{
      gooiedges[i,1]=Term(term[[as.character(gooiedges[i,1])]])
  }
  
  if(length(GOlist$term[GOlist$category==gooiedges[i,2]])>0){
    gooiedges[i,2]=GOlist$term[GOlist$category==gooiedges[i,2]]
  }else{
    gooiedges[i,2]=Term(term[[as.character(gooiedges[i,2])]])
  }
  i=i+1
}



nodeid=unique(c(gooiedges[,1],gooiedges[,2]))

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    gooiedges[,1],
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

  if(length(intersect(
    intersect( setdiff(gooiedges[,1],gooiedges[,2]),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  i=i+1
}

notsigs=nodeid[nodegroups=="not sig."]
nodeid=nodeid[nodegroups!="not sig."]
nodegroups=nodegroups[nodegroups!="not sig."]

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }  
  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

    if(length(intersect(
    intersect( setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  

  i=i+1
}

nodesize=c(rep(.1,length(nodeid)))
i=1
while(i<=length(nodeid)){
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodesize[i]=GOlist[GOlist$term==nodeid[i],4]
  }
  i=i+1
}


nodes=data.frame(id=nodeid,group=nodegroups,value=nodesize)
visedges=as.data.frame(gooiedges)
colnames(visedges)=c("from","to")
visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "Parent Term", shape = "square", color = list(background = "yellow", border="black", groupname="white"),physics=F,font=list(color="black"))%>%

  visGroups(groupname = "Not sig. Parent Term", shape = "square", color = list(background = "grey", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "yellow", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)


```

PC1BP group 1
protein and rna export to and from the nucleus
```{r}
PC1g1nodes=nodeid
PC1BPg1=intersect(unique(c(allchildren[,1],allchildren[,3])),PC1GO[PC1GO[,7]=="BP",1])
PC1BPg1=intersect(unique(c(allchildren[,1],allchildren[,3])),PC1GO[PC1GO[,7]=="BP"&PC1GO[,8]<.05,1])
##write.csv(na.omit(id2name[PC1BPg1]),"/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/PC1BPg1.csv")
PC1BPg1=as.character(unique(unlist(PC1gtg[PC1BPg1])))

```

```{r}

##"CC" "MF" "BP"
ont="BP"
##ccpar mfpar bppar
parent=bppar
##ccchild mfchild bpchild
child=bpchild
##a GOseq output table
tPC1=PC1GO
row.names(tPC1)=PC1GO$term
allsiggo=PC1GO$category[PC1GO$adjp<.05]
GOlist=tPC1["gene expression","category"]
goi=toppc1

##generates a table with all child terms for each significant GO term
  temp=GOlist
  temp2=child[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp5
  temp7[,2]=temp6
  temp7[,3]=temp4
  colnames(temp7)=c("parent","relationship","child")
  allchildren=temp7
  tested=unique(allchildren[,1])
  while(length(setdiff(unique(allchildren[,3]),tested))>0){
    temp=setdiff(unique(allchildren[,3]),tested)[1]
    temp2=child[temp]
    temp3=unlist(temp2)
    temp4=as.vector(temp3)
    temp5=as.vector(substring(names(temp3),1,10))
    temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
    temp7=matrix(0,nrow=length(temp3),ncol=3)
    temp7[,1]=temp5
    temp7[,2]=temp6
    temp7[,3]=temp4
    colnames(temp7)=c("parent","relationship","child")
    tested=unique(c(tested,temp))
    allchildren=rbind(allchildren,temp7)
    temp=c(rep(0,nrow(allchildren)))
    i=1
    while(i<=length(temp)){
      temp[i]=length(intersect(allchildren[i,],allsiggo))
      i=i+1
    }
    allchildren=allchildren[temp>0,]
  
  }

  temp=c(rep(0,nrow(allchildren)))
  i=1
while(i<=length(temp)){
  temp[i]=length(intersect(allchildren[,3],allsiggo))
  i=i+1
}

allchildren=allchildren[temp>0,]


    
edges=allchildren

gooiedges=unique(edges[,c(1,3)])
colnames(gooiedges)=c("from","to")
gooiedges=na.omit(gooiedges)

GOlist=PC1GO
i=1
while(i<=nrow(gooiedges)){
  if(length(GOlist$term[GOlist$category==gooiedges[i,1]])>0){
    gooiedges[i,1]=GOlist$term[GOlist$category==gooiedges[i,1]]
  }else{
      gooiedges[i,1]=Term(term[[as.character(gooiedges[i,1])]])
  }
  
  if(length(GOlist$term[GOlist$category==gooiedges[i,2]])>0){
    gooiedges[i,2]=GOlist$term[GOlist$category==gooiedges[i,2]]
  }else{
    gooiedges[i,2]=Term(term[[as.character(gooiedges[i,2])]])
  }
  i=i+1
}



nodeid=unique(c(gooiedges[,1],gooiedges[,2]))

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    gooiedges[,1],
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

  if(length(intersect(
    intersect( setdiff(gooiedges[,1],gooiedges[,2]),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  i=i+1
}

notsigs=nodeid[nodegroups=="not sig."]
nodeid=nodeid[nodegroups!="not sig."]
nodegroups=nodegroups[nodegroups!="not sig."]

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }  
  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

    if(length(intersect(
    intersect( setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  

  i=i+1
}

nodesize=c(rep(.1,length(nodeid)))
i=1
while(i<=length(nodeid)){
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodesize[i]=GOlist[GOlist$term==nodeid[i],4]
  }
  i=i+1
}


nodes=data.frame(id=nodeid,group=nodegroups,value=nodesize)
visedges=as.data.frame(gooiedges)
colnames(visedges)=c("from","to")
visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "Parent Term", shape = "square", color = list(background = "yellow", border="black", groupname="white"),physics=F,font=list(color="black"))%>%

  visGroups(groupname = "Not sig. Parent Term", shape = "square", color = list(background = "grey", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "yellow", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)


```


PC1BP group 2
gene expression
  regulation of RNA splicing
  translation
  transcription, DNA templated

```{r}
PC1g2nodes=nodeid
PC1BPg2=intersect(unique(c(allchildren[,1],allchildren[,3])),PC1GO[PC1GO[,7]=="BP",1])
PC1BPg2=intersect(unique(c(allchildren[,1],allchildren[,3])),PC1GO[PC1GO[,7]=="BP"&PC1GO[,8]<.05,1])
##write.csv(na.omit(id2name[PC1BPg2]),"/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/PC1BPg2.csv")
PC1BPg2=as.character(unique(unlist(PC1gtg[PC1BPg2])))

```

```{r}

##"CC" "MF" "BP"
ont="BP"
##ccpar mfpar bppar
parent=bppar
##ccchild mfchild bpchild
child=bpchild
##a GOseq output table
tPC1=PC1GO
row.names(tPC1)=PC1GO$term
allsiggo=PC1GO$category[PC1GO$adjp<.05]
GOlist=tPC1["cellular metabolic process","category"]
goi=toppc1

##generates a table with all child terms for each significant GO term
  temp=GOlist
  temp2=child[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp5
  temp7[,2]=temp6
  temp7[,3]=temp4
  colnames(temp7)=c("parent","relationship","child")
  allchildren=temp7
  tested=unique(allchildren[,1])
  while(length(setdiff(unique(allchildren[,3]),tested))>0){
    temp=setdiff(unique(allchildren[,3]),tested)[1]
    temp2=child[temp]
    temp3=unlist(temp2)
    temp4=as.vector(temp3)
    temp5=as.vector(substring(names(temp3),1,10))
    temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
    temp7=matrix(0,nrow=length(temp3),ncol=3)
    temp7[,1]=temp5
    temp7[,2]=temp6
    temp7[,3]=temp4
    colnames(temp7)=c("parent","relationship","child")
    tested=unique(c(tested,temp))
    allchildren=rbind(allchildren,temp7)
    temp=c(rep(0,nrow(allchildren)))
    i=1
    while(i<=length(temp)){
      temp[i]=length(intersect(allchildren[i,],allsiggo))
      i=i+1
    }
    allchildren=allchildren[temp>0,]
  
  }

  temp=c(rep(0,nrow(allchildren)))
  i=1
while(i<=length(temp)){
  temp[i]=length(intersect(allchildren[,3],allsiggo))
  i=i+1
}

allchildren=allchildren[temp>0,]


    
edges=allchildren

gooiedges=unique(edges[,c(1,3)])
colnames(gooiedges)=c("from","to")
gooiedges=na.omit(gooiedges)

GOlist=PC1GO
i=1
while(i<=nrow(gooiedges)){
  if(length(GOlist$term[GOlist$category==gooiedges[i,1]])>0){
    gooiedges[i,1]=GOlist$term[GOlist$category==gooiedges[i,1]]
  }else{
      gooiedges[i,1]=Term(term[[as.character(gooiedges[i,1])]])
  }
  
  if(length(GOlist$term[GOlist$category==gooiedges[i,2]])>0){
    gooiedges[i,2]=GOlist$term[GOlist$category==gooiedges[i,2]]
  }else{
    gooiedges[i,2]=Term(term[[as.character(gooiedges[i,2])]])
  }
  i=i+1
}



nodeid=unique(c(gooiedges[,1],gooiedges[,2]))

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    gooiedges[,1],
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

  if(length(intersect(
    intersect( setdiff(gooiedges[,1],gooiedges[,2]),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  i=i+1
}

notsigs=nodeid[nodegroups=="not sig."]
nodeid=nodeid[nodegroups!="not sig."]
nodegroups=nodegroups[nodegroups!="not sig."]

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }  
  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

    if(length(intersect(
    intersect( setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  

  i=i+1
}

nodesize=c(rep(.1,length(nodeid)))
i=1
while(i<=length(nodeid)){
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodesize[i]=GOlist[GOlist$term==nodeid[i],4]
  }
  i=i+1
}


nodes=data.frame(id=nodeid,group=nodegroups,value=nodesize)
visedges=as.data.frame(gooiedges)
colnames(visedges)=c("from","to")
visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "Parent Term", shape = "square", color = list(background = "yellow", border="black", groupname="white"),physics=F,font=list(color="black"))%>%

  visGroups(groupname = "Not sig. Parent Term", shape = "square", color = list(background = "grey", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "yellow", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)


```


PC1BP group 3
  cellular metabolic process
    RNA metabolic process

```{r}
PC1g3nodes=nodeid
PC1BPg3=intersect(unique(c(allchildren[,1],allchildren[,3])),PC1GO[PC1GO[,7]=="BP",1])
PC1BPg3=intersect(unique(c(allchildren[,1],allchildren[,3])),PC1GO[PC1GO[,7]=="BP"&PC1GO[,8]<.05,1])

##write.csv(na.omit(id2name[PC1BPg3]),"/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/PC1BPg3.csv")

PC1BPg3=as.character(unique(unlist(PC1gtg[PC1BPg3])))

```


##Coloring the original network by groups
```{r}


names(PC1groups)=PC1nodeid
PC1groups[setdiff(PC1g1nodes,c(PC1g2nodes,PC1g3nodes))]="group1"
PC1groups[setdiff(PC1g2nodes,c(PC1g1nodes,PC1g3nodes))]="group2"
PC1groups[setdiff(PC1g3nodes,c(PC1g2nodes,PC1g1nodes))]="group3"
PC1groups[intersect(PC1g1nodes,PC1g2nodes)]="group1 and group2"
PC1groups[intersect(PC1g1nodes,PC1g3nodes)]="group1 and group3"
PC1groups[intersect(PC1g3nodes,PC1g2nodes)]="group2 and group3"
PC1groups[grep("Not",PC1groups)]="not sig."
PC1groups[grep("Top 5 Sig. Enriched",PC1groups)]="Significantly Enriched"
PC1groups=as.vector(PC1groups)

nodes=data.frame(id=PC1nodeid,group=PC1groups,value=PC1size)
visedges=as.data.frame(PC1edges)
colnames(visedges)=c("from","to")



visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "group1", shape = "dot", color = list(background = "red", border="firebrick", groupname="white"),physics=T,font=list(color="black"))%>%
    visGroups(groupname = "group2", shape = "dot", color = list(background = "dodgerblue", border="royalblue", groupname="white"),physics=T,font=list(color="black"))%>%
    visGroups(groupname = "group3", shape = "dot", color = list(background = "yellow", border="gold3", groupname="white"),physics=T,font=list(color="black"))%>%
  
      visGroups(groupname = "group2 and group3", shape = "dot", color = list(background = "green", border="darkgreen", groupname="white"),physics=T,font=list(color="black"))%>%
      visGroups(groupname = "group1 and group2", shape = "dot", color = list(background = "violet", border="darkviolet", groupname="white"),physics=T,font=list(color="black"))%>%
  

  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "white", border="black", groupname="black"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)

```


```{r}

##"CC" "MF" "BP"
ont="BP"
##ccpar mfpar bppar
parent=bppar
##ccchild mfchild bpchild
child=bpchild
##a GOseq output table
tPC1=PC1GO
row.names(tPC1)=PC1GO$term
allsiggo=PC1GO$category[PC1GO$adjp<.05]
GOlist=tPC1["I-kappaB kinase/NF-kappaB signaling","category"]
goi=toppc1

##generates a table with all child terms for each significant GO term
  temp=GOlist
  temp2=child[temp]
  temp3=unlist(temp2)
  temp4=as.vector(temp3)
  temp5=as.vector(substring(names(temp3),1,10))
  temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
  temp7=matrix(0,nrow=length(temp3),ncol=3)
  temp7[,1]=temp5
  temp7[,2]=temp6
  temp7[,3]=temp4
  colnames(temp7)=c("parent","relationship","child")
  allchildren=temp7
  tested=unique(allchildren[,1])
  while(length(setdiff(unique(allchildren[,3]),tested))>0){
    temp=setdiff(unique(allchildren[,3]),tested)[1]
    temp2=child[temp]
    temp3=unlist(temp2)
    temp4=as.vector(temp3)
    temp5=as.vector(substring(names(temp3),1,10))
    temp6=as.vector(substring(names(temp3),12,nchar(names(temp3))))
    temp7=matrix(0,nrow=length(temp3),ncol=3)
    temp7[,1]=temp5
    temp7[,2]=temp6
    temp7[,3]=temp4
    colnames(temp7)=c("parent","relationship","child")
    tested=unique(c(tested,temp))
    allchildren=rbind(allchildren,temp7)
    temp=c(rep(0,nrow(allchildren)))
    i=1
    while(i<=length(temp)){
      temp[i]=length(intersect(allchildren[i,],allsiggo))
      i=i+1
    }
    allchildren=allchildren[temp>0,]
  
  }

  temp=c(rep(0,nrow(allchildren)))
  i=1
while(i<=length(temp)){
  temp[i]=length(intersect(allchildren[,3],allsiggo))
  i=i+1
}

allchildren=allchildren[temp>0,]


    
edges=allchildren

gooiedges=unique(edges[,c(1,3)])
colnames(gooiedges)=c("from","to")
gooiedges=na.omit(gooiedges)

GOlist=PC1GO
i=1
while(i<=nrow(gooiedges)){
  if(length(GOlist$term[GOlist$category==gooiedges[i,1]])>0){
    gooiedges[i,1]=GOlist$term[GOlist$category==gooiedges[i,1]]
  }else{
      gooiedges[i,1]=Term(term[[as.character(gooiedges[i,1])]])
  }
  
  if(length(GOlist$term[GOlist$category==gooiedges[i,2]])>0){
    gooiedges[i,2]=GOlist$term[GOlist$category==gooiedges[i,2]]
  }else{
    gooiedges[i,2]=Term(term[[as.character(gooiedges[i,2])]])
  }
  i=i+1
}



nodeid=unique(c(gooiedges[,1],gooiedges[,2]))

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<length(nodegroups)){
  if(length(intersect(
    gooiedges[,1],
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

  if(length(intersect(
    intersect( setdiff(gooiedges[,1],gooiedges[,2]),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  
  i=i+1
}

notsigs=nodeid[nodegroups=="not sig."]
nodeid=nodeid[nodegroups!="not sig."]
nodegroups=nodegroups[nodegroups!="not sig."]

nodegroups=rep("not sig.",length(nodeid))
i=1
while(i<=length(nodegroups)){
  if(length(intersect(
    setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),
    nodeid[i]))>0){
    nodegroups[i]="Not sig. Parent Term"
  }  
  
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodegroups[i]="Significantly Enriched"
  }

    if(length(intersect(
    intersect( setdiff(gooiedges[,1],setdiff(gooiedges[,2],notsigs)),GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]),
    nodeid[i]))>0){
    nodegroups[i]="Parent Term"
  }  

  i=i+1
}

nodesize=c(rep(.1,length(nodeid)))
i=1
while(i<=length(nodeid)){
  if(length(intersect(nodeid[i],GOlist$term[GOlist$adjp<.05&GOlist$ontology==ont]))>0){
    nodesize[i]=GOlist[GOlist$term==nodeid[i],4]
  }
  i=i+1
}


nodes=data.frame(id=nodeid,group=nodegroups,value=nodesize)
visedges=as.data.frame(gooiedges)
colnames(visedges)=c("from","to")
visNetwork(nodes,visedges)%>%
  visLayout(hierarchical=F, improvedLayout=T)%>%
  ##visPhysics(solver="forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant=-50),enabled=T)%>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)%>%
  visEdges(arrows='to')%>%
  visGroups(groupname = "Parent Term", shape = "square", color = list(background = "yellow", border="black", groupname="white"),physics=F,font=list(color="black"))%>%

  visGroups(groupname = "Not sig. Parent Term", shape = "square", color = list(background = "grey", border="black", groupname="white"),physics=F,font=list(color="black"))%>%
  visGroups(groupname = "Significantly Enriched", shape = "dot", color = list(background = "yellow", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visGroups(groupname = "not sig.", shape = "dot", color = list(background = "grey", border="black", groupname="white"),physics=T,font=list(color="black"),mass=3.5)%>%
  visLegend(width=.2)


```

```{r}
PC1BPg4=unique(c(allchildren[,1],allchildren[,3]))
PC1BPg4=as.character(unique(unlist(PC1gtg[PC1BPg4])))

```

```{r}

##Venn Code
library(VennDiagram)

##Sample titles as strings. Only fill in up to your number of selected categories
set1="Group 1"
set2="Group 2"
set3="Group 3"
set4="All Top 10 Percent"
  
  
##items to be compared (ex: gene names) as a 1 dimensional vectors. Only give inputs up to your number of selected categories
s1=PC1BPg1
s2=PC1BPg2
s3=PC1BPg3
s4=row.names(hmd)

##Quad Venn

grid.newpage()
tempvenn=draw.quad.venn(area1=length(s1),area2=length(s2),area3=length(s3),area4=length(s4), n12=length(intersect(s1,s2)),n13 = length(intersect(s1,s3)),n14 = length(intersect(s1,s4)),n23 = length(intersect(s2,s3)),n24 = length(intersect(s2,s4)),n34 = length(intersect(s3,s4)),n123 =  length(intersect(s1,intersect(s2,s3))),n124 =  length(intersect(s1,intersect(s2,s4))), n134 = length(intersect(s1,intersect(s3,s4))),n234 = length(intersect(s2,intersect(s3,s4))),n1234 = length(intersect(s1,intersect(s2,intersect(s3,s4)))),category =c(set1,set2,set3,set4),fill = c("blue", "red","green","yellow"),cex=2,cat.cex = 1)

##Triple Venn

grid.newpage()
draw.triple.venn(area1=length(s1),area2=length(s2),area3=length(s3),n12=length(intersect(s1,s2)),n23 = length(intersect(s2,s3)),n13 = length(intersect(s1,s3)),n123 = length(intersect(intersect(s1,s2),s3)),category=c(set1,set2,set3),fill = c("green", "blue","red"),cex=1.5,cat.cex = 1)

```

```{r include=F}

hmorder=c((setdiff(s1,c(s2,s3))),
          (intersect(s1,intersect(s2,s3))),
          (setdiff(intersect(s3,s2),s1)),
          (setdiff(s3,c(s1,s2))),
          (setdiff(intersect(s3,s1),s2)))
split=c(rep("A",length(setdiff(s1,c(s2,s3)))),
          rep("B",length(intersect(s1,intersect(s2,s3)))),
          rep("C",length(setdiff(intersect(s3,s2),s1))),
          rep("D",length(setdiff(s3,c(s1,s2)))),
          rep("E",length(setdiff(intersect(s3,s1),s2))))
colgroups=c(rep("A",length(setdiff(s1,c(s2,s3)))),
          rep("B",length(intersect(s1,intersect(s2,s3)))),
          rep("C",length(setdiff(intersect(s3,s2),s1))),
          rep("D",length(setdiff(s3,c(s1,s2)))),
          rep("E",length(setdiff(intersect(s3,s1),s2))))
mat1 = (scalemeancpm)[hmorder,]
sigs=bitr(row.names(mat1),fromType = "ENSEMBL", toType = "SYMBOL",  OrgDb="org.Hs.eg.db")
sigs1=sigs[,2]
names(sigs1)=sigs[,1]
row.names(mat1)=sigs1[row.names(mat1)]
mat2 = mat1[,c(6,5,4)]
mat1=mat1[,c(3,2,1)]

##write.csv(mat1,"/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/PC1mat1")
##write.csv(mat2,"/Users/johncsantiago/Google Drive File Stream/My Drive/Sanders Lab Files/All Code/PC1mat2")

##split = sample(letters[1:6], 100, replace = TRUE)
split = factor(split, levels = unique(split))
```

```{r fig.height=6,fig.width=6}
circos.clear()
circos.par(gap.after = c(2, 2, 2, 2, 7))
col_fun1 = colorRamp2(c(-2, 0, 2), c("royalblue4","white","firebrick4"))
circos.heatmap(mat1, col = col_fun1, rownames.cex=.2,track.height=.2, split = split, rownames.side = "outside")
col_direction = c("A" = "forestgreen", "B" = "forestgreen","C" = "white","D" = "white","E" = "forestgreen")
colgroups=as.vector(split)
circos.heatmap(colgroups,col = col_direction,track.height=.025)
col_direction = c("A" = "white", "B" = "cornflowerblue","C" = "cornflowerblue","D" = "white","E" = "white")
circos.heatmap(colgroups,col = col_direction,track.height=.025)
col_direction = c("A" = "white", "B" = "gold","C" = "gold","D" = "gold","E" = "gold")
circos.heatmap(colgroups,col = col_direction,track.height=.025)
legend(x=-.5,y=.4,legend=c("Protein and RNA transport \nto and from the nucleus","gene expression: Transcription, \nRNA splicing, and Translation","DNA, RNA, and Protein Biosynthesis"),fill=c("forestgreen","cornflowerblue","gold"),bty="n",title="Viable",cex=.8,y.intersp=2)
arrows(x0=.7,y0=0.02,x1=.9,y1=0.02,length=.05)

text(x=.72,y=.05,labels="0H",cex=.5)
text(x=.80,y=.05,labels="3H",cex=.5)
text(x=.87,y=.05,labels="6H",cex=.5)

```

```{r fig.height=6,fig.width=6}
circos.clear()
circos.par(gap.after = c(2, 2, 2, 2, 7))
col_fun1 = colorRamp2(c(-2, 0, 2), c("royalblue4","white","firebrick4"))
circos.heatmap(mat2, col = col_fun1, rownames.cex=.2,track.height=.2, split = split, rownames.side = "outside")
col_direction = c("A" = "forestgreen", "B" = "forestgreen","C" = "white","D" = "white","E" = "forestgreen")
colgroups=as.vector(split)
circos.heatmap(colgroups,col = col_direction,track.height=.025)
col_direction = c("A" = "white", "B" = "cornflowerblue","C" = "cornflowerblue","D" = "white","E" = "white")
circos.heatmap(colgroups,col = col_direction,track.height=.025)
col_direction = c("A" = "white", "B" = "gold","C" = "gold","D" = "gold","E" = "gold")
circos.heatmap(colgroups,col = col_direction,track.height=.025)
legend(x=-.5,y=.4,legend=c("Protein and RNA transport \nto and from the nucleus","gene expression: Transcription, \nRNA splicing, and Translation","DNA, RNA, and Protein Biosynthesis"),fill=c("forestgreen","cornflowerblue","gold"),bty="n",title="Non-Viable",cex=.8,y.intersp=2)
arrows(x0=.7,y0=0.02,x1=.9,y1=0.02,length=.05)

text(x=.72,y=.05,labels="0H",cex=.5)
text(x=.80,y=.05,labels="3H",cex=.5)
text(x=.87,y=.05,labels="6H",cex=.5)
```




PC1 MF
Looks like transcription and translation function (RNA and protein binding )
```{r}
##"CC" "MF" "BP"
ont="MF"
##ccpar mfpar bppar
parent=mfpar
##ccchild mfchild bpchild
child=mfchild
##a GOseq output table
GOlist=PC1GO
goi=toppc1
GOnetwork(ont,parent,child,GOlist,goi)
  
```


